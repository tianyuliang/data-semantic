# 库表数据理解需求方案设计

> 基于业务对象管理界面的数据表结构设计
> 创建时间: 2026-01-30
> 更新时间: 2026-01-30 (关联现有 form_view_field 表)

## 一、设计概述

本设计方案实现了业务语义与数据存储的解耦，核心思想是：

- **业务对象（Business Object）**：业务实体的抽象
- **属性（Attribute）**：业务语义的抽象，关联到现有的 `form_view_field` 表

## 二、ER关系图

```
                      ┌──────────────────┐
                      │   form_view      │  数据视图
                      └──────────────────┘
                              │
                              │ 1:N
                              │
           ┌─────────────────────────────────────────────────────────┐
           │                                                         │
           │ 1:N                                                    │ 1:N
           │                                                         │
┌──────────────────────┐                                ┌──────────────────────────────┐
│ t_business_object    │  业务对象表                      │ t_business_object_attributes │  业务对象属性表
└──────────┬───────────┘                                └────────────┬───────────────────┘
           │                                                              │
           │ 1:N                                                          │
           │                                                              │
           └──────────────────────────────────────────────────────────────┘
                                                                        │
                                                                        │ 1:1
                                                                        │
                                                          ┌─────────────────┐
                                                          │form_view_field  │  现有字段表
                                                          └─────────────────┘
```

## 三、数据表设计

> **【强制执行】本章节定义的所有数据表结构必须严格按照当前设计执行，不得擅自修改字段名称、类型、约束或索引。任何修改需经过完整评审流程。**

### 数据表汇总

| 表名                               | 类型     | 说明                               |
| ---------------------------------- | -------- | ---------------------------------- |
| `t_business_object`                | 正式表   | 业务对象正式表                     |
| `t_business_object_attributes`     | 正式表   | 业务对象属性正式表                 |
| `form_view_field`                  | 现有表   | 现有字段表（需扩展字段）           |
| `form_view`                        | 现有表   | 数据视图表（需扩展字段）           |
| `t_business_object_temp`           | 临时表   | 业务对象临时表（支持版本控制）     |
| `t_business_object_attributes_temp` | 临时表   | 业务对象属性临时表（支持版本控制） |
| `t_form_view_info_temp`            | 临时表   | 库表信息临时表（支持版本控制）     |
| `t_form_view_field_info_temp`      | 临时表   | 库表字段信息临时表（支持版本控制） |
| `t_kafka_message_log`              | 辅助表   | Kafka消息处理记录表                |

### 3.1 业务对象表 `t_business_object`

存储业务对象的基本信息，区分已发布业务对象和候选业务对象。

```sql
CREATE TABLE IF NOT EXISTS t_business_object (
    id             CHAR(36)     NOT NULL                       COMMENT '业务对象UUID（主键）',
    object_name    VARCHAR(100) NOT NULL                       COMMENT '业务对象名称',
    object_type    TINYINT      NOT NULL DEFAULT 0             COMMENT '对象类型：0-候选业务对象,1-已发布业务对象',
    form_view_id   CHAR(36)     NOT NULL                       COMMENT '关联数据视图UUID',
    status         TINYINT      NOT NULL DEFAULT 1             COMMENT '状态：0-禁用,1-启用',
    created_at     DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    updated_at     DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    deleted_at     DATETIME(3)          DEFAULT NULL           COMMENT '删除时间(逻辑删除)',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='业务对象表';
```

### 3.2 业务对象属性表 `t_business_object_attributes`

存储业务对象的属性定义，关联到现有的 `form_view_field` 表获取字段信息。

```sql
CREATE TABLE IF NOT EXISTS t_business_object_attributes (
    id                   CHAR(36)     NOT NULL                       COMMENT '属性UUID（主键）',
    form_view_id         CHAR(36)     NOT NULL                       COMMENT '关联数据视图UUID',
    business_object_id   CHAR(36)     NOT NULL                       COMMENT '关联业务对象UUID',
    form_view_field_id   CHAR(36)     NOT NULL                       COMMENT '关联字段UUID',
    attr_name            VARCHAR(100) NOT NULL                       COMMENT '属性名称',
    created_at           DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    updated_at           DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    deleted_at           DATETIME(3)          DEFAULT NULL           COMMENT '删除时间(逻辑删除)',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='业务对象属性表';
```

### 3.3 现有字段表 `form_view_field` (参考)

```sql
CREATE TABLE form_view_field (
    form_view_field_id      BIGINT(20)  NOT NULL                    COMMENT '列唯一id',
    id                      CHAR(36)    NOT NULL                    COMMENT 'uuid',
    form_view_id            CHAR(36)    NOT NULL                    COMMENT '数据视图uuid',
    technical_name          VARCHAR(255) NOT NULL                   COMMENT '列技术名称',
    business_name           VARCHAR(255)        DEFAULT NULL        COMMENT '列业务名称',
    original_name           VARCHAR(255)        DEFAULT NULL        COMMENT '原始字段名称',
    comment                 TEXT                DEFAULT NULL        COMMENT '列注释',
    status                  INT(11)     NOT NULL                    COMMENT '列视图状态（在逻辑删除）0：无变化、1：新增、2：删除',
    primary_key             INT(1)              DEFAULT NULL        COMMENT '是否主键',
    data_type               VARCHAR(255)        DEFAULT NULL        COMMENT '数据类型',
    data_length             INT(11)     NOT NULL                    COMMENT '数据长度',
    data_accuracy           INT(11)     NOT NULL                    COMMENT '数据精度（@DECIMAL类型）',
    original_data_type      VARCHAR(255) NOT NULL                    COMMENT '原始数据类型',
    is_nullable             VARCHAR(30) NOT NULL                    COMMENT '是否为空',
    deleted_at              DATETIME(3)  DEFAULT NULL          COMMENT '删除时间（逻辑删除）',
    standard_code           VARCHAR(30)         DEFAULT NULL        COMMENT '数据标准code',
    standard                VARCHAR(255)        DEFAULT NULL        COMMENT '数据标准名称',
    code_table              VARCHAR(30)         DEFAULT NULL        COMMENT '在表ID',
    business_timestamp      INT(1)              DEFAULT NULL        COMMENT '业务时间字段有字段',
    reset_before_data_type  VARCHAR(255)        DEFAULT NULL        COMMENT '重置前类型',
    reset_convert_rules     VARCHAR(255)        DEFAULT NULL        COMMENT '重置转换规则（仅日期类型）',
    reset_data_length       INT(11)             DEFAULT NULL        COMMENT '重置数据长度（@DECIMAL类型）',
    reset_data_accuracy     INT(11)             DEFAULT NULL        COMMENT '重置数据精度（@DECIMAL类型）',
    index                   INT(11)     NOT NULL                    COMMENT '字段顺序',
    subject_id              CHAR(36)            DEFAULT NULL        COMMENT '关联数据实体ID（L5）',
    classify_type           VARCHAR(10)         DEFAULT NULL        COMMENT '数据分类（自动分类）2：manual（人工分类）',
    match_score             VARCHAR(10)         DEFAULT NULL        COMMENT '数据实体匹配匹配评分（满分100分，如需要具体分匹配度分表示）',
    grade_id                BIGINT(20)          DEFAULT NULL        COMMENT '分级规则id',
    grade_type              INT(1)              DEFAULT NULL        COMMENT '数据分级规则获取方式 1：auto（自动匹配分级） 2：manual（人工选择分级）',
    shared_type             INT(11)             DEFAULT 0           COMMENT '共享属性',
    open_type               INT(11)             DEFAULT 0           COMMENT '开放属性',
    sensitive_type          INT(11)             DEFAULT NULL        COMMENT '敏感属性',
    secret_type             INT(11)             DEFAULT NULL        COMMENT '涉密属性',
    PRIMARY KEY (form_view_field_id),
    KEY form_view_id_btr (form_view_id),
    KEY id_btr (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='逻辑视图字段表';
```

### 3.4 数据视图表扩展字段

为 `form_view` 表增加理解状态字段，用于标识库表的理解进度：

```sql
-- 为 form_view 表增加理解状态字段
ALTER TABLE form_view
ADD COLUMN IF NOT EXISTS understand_status TINYINT NOT NULL DEFAULT 0 COMMENT '理解状态：0-未理解,1-理解中,2-待确认,3-已完成,4-已发布,5-理解失败';
```

**理解状态说明：**

| 状态值 | 状态名称 | 说明                   |
| ------ | -------- | ---------------------- |
| 0      | 未理解   | 尚未进行库表理解操作     |
| 1      | 理解中   | 正在进行库表理解操作     |
| 2      | 待确认   | 理解完成，待用户确认     |
| 3      | 已完成   | 已完成库表理解          |
| 4      | 已发布   | 业务对象已正式发布      |
| 5      | 理解失败 | AI理解失败，可重新尝试 |

### 3.5 字段表扩展字段

根据设计稿，为 `form_view_field` 表增加两个字段：

```sql
-- 为 form_view_field 表增加三个字段
ALTER TABLE form_view_field
ADD COLUMN IF NOT EXISTS field_role TINYINT DEFAULT NULL COMMENT '字段角色：1-业务主键, 2-关联标识, 3-业务状态, 4-时间字段, 5-业务指标, 6-业务特征, 7-审计字段, 8-技术字段' AFTER business_name,
ADD COLUMN IF NOT EXISTS field_description VARCHAR(300) DEFAULT NULL COMMENT '字段描述' AFTER comment;
```

### 3.6 业务对象临时表 `t_business_object_temp`

用于在用户提交确认前临时保存业务对象的编辑操作，支持版本控制。

```sql
CREATE TABLE IF NOT EXISTS t_business_object_temp (
    id             CHAR(36)     NOT NULL                       COMMENT '业务对象UUID（主键）',
    form_view_id   CHAR(36)     NOT NULL                       COMMENT '关联数据视图UUID',
    user_id        CHAR(36)                                         COMMENT '为空代表模型操作，不为空代表某用户操作',
    version        INT          NOT NULL DEFAULT 10            COMMENT '版本号（存储格式：10=1.0，11=1.1，每次递增1表示0.1版本）',
    object_name    VARCHAR(100) NOT NULL                       COMMENT '业务对象名称',
    formal_id      CHAR(36)                                         COMMENT '关联正式表ID（用于增量更新匹配，首次提交后回写）',
    created_at     DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    updated_at     DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    deleted_at     DATETIME(3)          DEFAULT NULL           COMMENT '删除时间(逻辑删除)',
    PRIMARY KEY (id),
    KEY idx_form_view_version (form_view_id, version, deleted_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='业务对象临时表';
```

**数据来源：**

1. **AI 自动生成**：通过订阅 Kafka 消息 `data-understanding-responses`，接收 AI 服务分析完成后返回的业务对象数据
2. **用户手动编辑**：用户在页面上编辑业务对象名称时保存的数据

**使用说明：**

- 用户在页面编辑业务对象时，先保存到此临时表
- 点击提交确认后，将数据迁移到正式表 `t_business_object`
- `formal_id` 用于关联正式表记录，实现增量更新：
  - 首次提交时 `formal_id` 为 NULL，提交后将新生成的正式表 ID 回写到此字段
  - 再次编辑提交时，通过 `formal_id` 精确匹配需要更新的记录，保持 ID 稳定性
  - 支持外部系统引用业务对象 ID 而不会因重新提交失效
- `user_id` 为空时代表 AI 模型自动操作（通过 Kafka 订阅），不为空时代表具体用户操作
- AI 自动生成时递增版本号，初始版本为10（显示为1.0），用户手动编辑时版本号不变
- 支持重新识别，AI 重新识别时会创建新版本记录，旧版本记录保留作为历史

### 3.7 业务对象属性临时表 `t_business_object_attributes_temp`

用于在用户提交确认前临时保存业务对象属性的编辑操作。

```sql
CREATE TABLE IF NOT EXISTS t_business_object_attributes_temp (
    id                          CHAR(36)     NOT NULL                       COMMENT '属性UUID（主键）',
    form_view_id                CHAR(36)     NOT NULL                       COMMENT '关联数据视图UUID',
    business_object_id          CHAR(36)     NOT NULL                       COMMENT '关联业务对象UUID',
    user_id                     CHAR(36)                                         COMMENT '为空代表模型操作，不为空代表某用户操作',
    version                     INT          NOT NULL DEFAULT 10            COMMENT '版本号（存储格式：10=1.0，11=1.1，每次递增1表示0.1版本）',
    form_view_field_id          CHAR(36)     NOT NULL                       COMMENT '关联字段UUID',
    attr_name                   VARCHAR(100) NOT NULL                       COMMENT '属性名称',
    formal_id                   CHAR(36)                                         COMMENT '关联正式表ID（用于增量更新匹配，首次提交后回写）',
    created_at                  DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    updated_at                  DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    deleted_at                  DATETIME(3)          DEFAULT NULL           COMMENT '删除时间(逻辑删除)',
    PRIMARY KEY (id),
    KEY idx_form_view_object (form_view_id, business_object_id, deleted_at),
    KEY idx_form_view_version (form_view_id, version, deleted_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='业务对象属性临时表';
```

**数据来源：**

1. **AI 自动生成**：通过订阅 Kafka 消息 `data-understanding-responses`，接收 AI 服务分析完成后返回的属性关联数据
2. **用户手动编辑**：用户在页面上编辑属性名称或调整属性归属业务对象时保存的数据

**使用说明：**

- 用户在页面编辑业务对象属性时，先保存到此临时表
- 点击提交确认后，将数据迁移到正式表 `t_business_object_attributes`
- `business_object_id` 用于关联业务对象临时表
- `formal_id` 用于关联正式表记录，实现增量更新：
  - 首次提交时 `formal_id` 为 NULL，提交后将新生成的正式表 ID 回写到此字段
  - 再次编辑提交时，通过 `formal_id` 精确匹配需要更新的记录，保持 ID 稳定性
- `user_id` 为空时代表 AI 模型自动操作（通过 Kafka 订阅），不为空时代表具体用户操作
- AI 自动生成时递增版本号，初始版本为10（显示为1.0），用户手动编辑时版本号不变

### 3.8 库表信息临时表 `t_form_view_info_temp`

临时记录库表的语义补全数据（包括 AI 自动生成和用户手动编辑），支持版本控制。

```sql
CREATE TABLE IF NOT EXISTS t_form_view_info_temp (
    id                   CHAR(36)     NOT NULL                       COMMENT '记录UUID（主键）',
    form_view_id         CHAR(36)     NOT NULL                       COMMENT '关联数据视图UUID',
    user_id              CHAR(36)                                         COMMENT '为空代表模型操作，不为空代表某用户操作',
    version              INT          NOT NULL DEFAULT 10            COMMENT '版本号（存储格式：10=1.0，11=1.1，每次递增1表示0.1版本）',

    -- 库表级别语义补全
    table_business_name  VARCHAR(255)        DEFAULT NULL            COMMENT '库表业务名称',
    table_description    VARCHAR(300)        DEFAULT NULL            COMMENT '库表描述',

    created_at           DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    updated_at           DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    deleted_at           DATETIME(3)          DEFAULT NULL           COMMENT '删除时间(逻辑删除)',

    PRIMARY KEY (id),
    KEY idx_form_view_version (form_view_id, version, deleted_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='库表信息临时表';
```

**数据来源：**

1. **AI 自动生成**：通过订阅 Kafka 消息 `data-understanding-responses`，接收 AI 服务分析完成后返回的库表语义理解数据
2. **用户手动编辑**：用户在页面上编辑库表业务名称、库表描述时保存的数据

**使用说明：**

- 专门存储库表级别的语义补全数据
- `user_id` 为空时代表 AI 模型自动操作（通过 Kafka 订阅），不为空时代表具体用户操作
- AI 自动生成时递增版本号，初始版本为10（显示为1.0），用户手动编辑时版本号不变
- AI 重新生成时会创建新版本记录，用户编辑则在当前版本上更新

---

### 3.9 库表字段信息临时表 `t_form_view_field_info_temp`

临时记录字段的语义补全数据（包括 AI 自动生成和用户手动编辑），支持版本控制。

```sql
CREATE TABLE IF NOT EXISTS t_form_view_field_info_temp (
    id                   CHAR(36)     NOT NULL                       COMMENT '记录UUID（主键）',
    form_view_id         CHAR(36)     NOT NULL                       COMMENT '关联数据视图UUID',
    form_view_field_id   CHAR(36)     NOT NULL                       COMMENT '关联字段UUID',
    user_id              CHAR(36)                                         COMMENT '为空代表模型操作，不为空代表某用户操作',
    version              INT          NOT NULL DEFAULT 10            COMMENT '版本号（存储格式：10=1.0，11=1.1，每次递增1表示0.1版本）',

    -- 字段级别语义补全
    field_business_name  VARCHAR(255)        DEFAULT NULL            COMMENT '字段业务名称',
    field_role           TINYINT             DEFAULT NULL            COMMENT '字段角色：1-业务主键, 2-关联标识, 3-业务状态, 4-时间字段, 5-业务指标, 6-业务特征, 7-审计字段, 8-技术字段',
    field_description    VARCHAR(300)        DEFAULT NULL            COMMENT '字段描述',

    created_at           DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) COMMENT '创建时间',
    updated_at           DATETIME(3)          DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3) COMMENT '更新时间',
    deleted_at           DATETIME(3)          DEFAULT NULL           COMMENT '删除时间(逻辑删除)',

    PRIMARY KEY (id),
    KEY idx_form_view_version (form_view_id, version, deleted_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='库表字段信息临时表';
```

**数据来源：**

1. **AI 自动生成**：通过订阅 Kafka 消息 `data-understanding-responses`，接收 AI 服务分析完成后返回的字段语义理解数据
2. **用户手动编辑**：用户在页面上编辑字段业务名称、字段角色、字段描述时保存的数据

**使用说明：**

- 专门存储字段级别的语义补全数据
- 每条记录对应一个字段的语义补全信息
- `user_id` 为空时代表 AI 模型自动操作（通过 Kafka 订阅），不为空时代表具体用户操作
- AI 自动生成时递增版本号，初始版本为10（显示为1.0），用户手动编辑时版本号不变
- AI 重新生成时会创建新版本记录，用户编辑则在当前版本上更新

**字段角色类型定义：**

| 枚举值 | 角色代码        | 角色名称 | 描述                   | 示例           |
| ------ | --------------- | -------- | ---------------------- | -------------- |
| 1      | BUSINESS_KEY    | 业务主键 | 用来标识一条业务记录   | 身份证号       |
| 2      | RELATED         | 关联标识 | 用于关联其他业务对象   | 姓名           |
| 3      | BUSINESS_STATUS | 业务状态 | 描述业务当前所处的阶段 | 订单状态       |
| 4      | TIME            | 时间字段 | 描述时间点或时间范围   | 创建时间       |
| 5      | METRIC          | 业务指标 | 可统计、可汇总的数值   | 金额、数量     |
| 6      | FEATURE         | 业务特征 | 描述业务特征的字段     | 地址、备注     |
| 7      | AUDIT           | 审计字段 | 用于记录创建/修改信息  | 创建人、修改人 |
| 8      | TECHNICAL       | 技术字段 | 系统或技术用途字段     | 版本号、标记位 |

---

## 四、API 接口设计

> **【强制执行】本章节定义的所有接口必须严格按照当前设计执行，包括请求参数、响应格式、处理逻辑、状态流转、异常处理等。接口实现需严格遵循第三章数据表设计规范，确保数据一致性和完整性。**

### 4.1 接口列表

| 序号 | 接口名称             | 请求方式 | 路由 |
| ---- | -------------------- | -------- | ---- |
| 1    | 查询字段语义补全数据 | GET      | `/data-semantic/{id}/fields` |
| 2    | 查询业务对象识别结果 | GET      | `/data-semantic/{id}/business-objects` |
| 3    | 提交理解数据         | POST     | `/data-semantic/{id}/submit` |
| 4    | 删除业务对象识别结果 | DELETE   | `/data-semantic/{id}/business-objects` |
| 5    | 重新识别业务对象     | POST     | `/data-semantic/{id}/business-objects/regenerate` |
| 6    | 一键生成理解数据     | POST     | `/data-semantic/{id}/generate` |
| 7    | 保存库表信息补全数据 | PUT      | `/data-semantic/{id}/semantic-info` |
| 8    | 保存业务对象及属性   | PUT      | `/data-semantic/{id}/business-objects` |
| 9    | 调整属性归属业务对象 | PUT      | `/data-semantic/{id}/business-objects/attributes/move` |
| 10   | 查询库表理解状态     | GET      | `/data-semantic/{id}/status` |

**路由设计说明**：
- **统一前缀**：所有接口使用 `/data-semantic` 作为统一前缀，清晰标识数据语义相关功能
- **资源层级**：按照「语义信息 → 业务对象 → 属性」的资源层级组织路由
- **RESTful风格**：遵循RESTful设计规范，使用资源名词而非动词
- **简洁性**：移除冗余的 `form-view` 概念，直接使用数据语义作为核心概念

---

### 4.2 错误码规范

所有接口使用统一的错误码规范，业务错误码范围为 `600101-600130`。

| 错误码范围    | 说明                                       |
| ------------- | ------------------------------------------ |
| 600101-600110 | 状态校验相关错误                           |
| 600111-600120 | 数据校验相关错误（如重复、不存在等）       |
| 600121-600130 | 业务逻辑相关错误（如并发冲突、权限不足等） |

**错误响应格式**：

```json
{
  "code": 600101,                           // int - 业务错误码（600101-600130）
  "message": "当前状态不允许操作",             // string - 错误消息
  "data": {
    "error_type": "invalid_status",         // string - 错误类型
    "error_detail": "当前理解状态为0，不允许操作" // string - 错误详情
  }
}
```

**HTTP状态码说明**：

| HTTP状态码 | 说明                       |
| ---------- | -------------------------- |
| 200        | 请求成功                   |
| 400        | 请求参数错误或业务逻辑错误 |
| 401        | 未授权（Token无效或过期）  |
| 403        | 无权限访问                 |
| 404        | 资源不存在                 |
| 500        | 服务器内部错误             |
| 503        | 服务不可用（如AI服务异常） |

---

### 4.3 接口详细说明

#### 4.3.1 查询字段语义补全数据

**接口路径**：`GET /api/v1/data-semantic/{id}/fields`

**请求参数**：

| 参数名          | 类型    | 必填 | 说明                                                                                               |
| --------------- | ------- | ---- | -------------------------------------------------------------------------------------------------- |
| id              | string  | 是   | 数据视图UUID                                                                                       |
| keyword         | string  | 否   | 搜索字段技术名称（模糊匹配 field_tech_name）                                                       |
| only_incomplete | boolean | 否   | 是否仅查看未完成理解的字段（字段业务名称、字段角色、字段描述任意一个为空即视为未完成），默认 false |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**处理逻辑**：

1. **查询当前理解状态**

   ```sql
   SELECT understand_status
   FROM form_view
   WHERE id = {form_view_id};
   ```
2. **状态判断处理**

   **2.1 状态为 1-理解中**

   返回错误响应：

   ```json
   {
     "code": 400,
     "message": "当前正在理解中，请稍后再试",
     "data": {
       "error_type": "understanding_in_progress",
       "understand_status": 1
     }
   }
   ```

   **2.2 状态为 0-未理解、3-已完成、4-已发布**

   从正式表查询数据：

   ```sql
   -- 查询库表信息
   SELECT
     technical_name AS table_tech_name,
     business_name AS table_business_name,
     description AS table_description
   FROM form_view
   WHERE id = {form_view_id} AND deleted_at IS NULL;

   -- 查询字段信息
   SELECT
     id AS form_view_field_id,
     technical_name AS field_tech_name,
     data_type AS field_type,
     field_business_name,
     field_role,
     field_description
   FROM form_view_field
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL
   ORDER BY `index` ASC;
   ```

   **2.3 状态为 2-待确认**

   从临时表获取字段属性信息，技术名称和字段类型从正式表获取：

   ```sql
   -- 获取当前版本号
   SELECT COALESCE(MAX(version), 10) AS current_version
   FROM t_form_view_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;

   -- 查询库表信息（临时表优先）
   SELECT
     fv.technical_name AS table_tech_name,
     COALESCE(fvit.table_business_name, fv.business_name) AS table_business_name,
     COALESCE(fvit.table_description, fv.description) AS table_description
   FROM form_view fv
   LEFT JOIN t_form_view_info_temp fvit
     ON fv.id = fvit.form_view_id
     AND fvit.version = {current_version}
     AND fvit.deleted_at IS NULL
   WHERE fv.id = {form_view_id} AND fv.deleted_at IS NULL;

   -- 查询字段信息（字段属性从临时表，技术名称和类型从正式表）
   SELECT
     fvf.id AS form_view_field_id,
     fvf.technical_name AS field_tech_name,
     fvf.data_type AS field_type,
     COALESCE(fvfit.field_business_name, fvf.field_business_name) AS field_business_name,
     COALESCE(fvfit.field_role, fvf.field_role) AS field_role,
     COALESCE(fvfit.field_description, fvf.field_description) AS field_description
   FROM form_view_field fvf
   LEFT JOIN t_form_view_field_info_temp fvfit
     ON fvf.id = fvfit.form_view_field_id
     AND fvfit.version = {current_version}
     AND fvfit.deleted_at IS NULL
   WHERE fvf.form_view_id = {form_view_id}
     AND fvf.deleted_at IS NULL
   ORDER BY fvf.`index` ASC;
   ```
3. **参数过滤处理**

   **3.1 keyword 不为空时，模糊匹配字段技术名称**

   ```sql
   -- 在 WHERE 子句中添加条件
   AND fvf.technical_name LIKE CONCAT('%', {keyword}, '%')
   ```

   **3.2 only_incomplete = true 时，过滤未完成的字段**

   *状态为 0-未理解、3-已完成、4-已发布时（查询正式表）：*

   ```sql
   -- 在 WHERE 子句中添加条件
   AND (
     business_name IS NULL OR business_name = ''
     OR field_role IS NULL
     OR field_description IS NULL OR field_description = ''
   )
   ```

   *状态为 2-待确认时（查询临时表）：*

   ```sql
   -- 在 WHERE 子句中添加条件
   AND (
     fvfit.field_business_name IS NULL OR fvfit.field_business_name = ''
     OR fvfit.field_role IS NULL
     OR fvfit.field_description IS NULL OR fvfit.field_description = ''
   )
   ```

**数据来源说明**：

根据 `understand_status` 状态决定数据来源：

| 状态     | 库表信息       | 字段信息        | 字段基本信息    |
| -------- | -------------- | --------------- | --------------- |
| 0-未理解 | form_view      | form_view_field | form_view_field |
| 1-理解中 | 禁止调用       | -               | -               |
| 2-待确认 | 临时表（优先） | 临时表（优先）  | form_view_field |
| 3-已完成 | form_view      | form_view_field | form_view_field |
| 4-已发布 | form_view      | form_view_field | form_view_field |

- `table_tech_name`：状态0/3/4来自 `form_view`，状态2临时表无此字段，仍来自 `form_view`
- `table_business_name`、`table_description`：状态0/3/4来自正式表，状态2临时表优先
- `field_tech_name`、`field_type`：始终来自 `form_view_field`
- `field_business_name`、`field_role`、`field_description`：状态0/3/4来自正式表，状态2临时表优先
- `current_version`：状态2时返回当前版本号，其他状态返回 0

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "data": {
    "current_version": 10,                     // int - 当前版本号（存储格式：10=1.0，显示时除以10）
    "table_business_name": "员工信息表",       // string - 库表业务名称
    "table_tech_name": "cowenrr",            // string - 库表技术名称（来自 form_view 表）
    "table_description": "员工基础信息表",    // string - 库表描述
    "fields": [                               // array - 字段级别语义补全信息列表
      {
        "form_view_field_id": "xxx",           // string - 字段UUID
        "field_business_name": "员工姓名",      // string - 字段业务名称
        "field_tech_name": "name",             // string - 字段技术名称（来自 form_view_field.technical_name）
        "field_type": "VARCHAR",               // string - 字段类型（来自 form_view_field.data_type）
        "field_role": 1,                       // int - 字段角色（1-业务主键, 2-关联标识, 3-业务状态, 4-时间字段, 5-业务指标, 6-业务特征, 7-审计字段, 8-技术字段）
        "field_description": "员工真实姓名"    // string - 字段描述
      }
    ]
  }
}
```

**说明**：

- `current_version` 通过 `COALESCE(MAX(version), 10)` 获取最大版本号（存储格式：10=1.0，显示时除以10）
- 返回的数据为最新版本的数据（通过版本号筛选）

---

#### 4.3.2 查询业务对象识别结果

**接口路径**：`GET /api/v1/data-semantic/{id}/business-objects`

**请求参数**：

| 参数名    | 类型   | 必填 | 说明                                                                |
| --------- | ------ | ---- | ------------------------------------------------------------------- |
| id        | string | 是   | 数据视图UUID                                                        |
| object_id | int    | 否   | 业务对象ID（传此参数则返回单个业务对象的详细数据）                  |
| keyword   | string | 否   | 搜索属性名称/字段业务名称（模糊匹配 attr_name/field_business_name） |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**处理逻辑**：

1. **查询当前理解状态**

   ```sql
   SELECT understand_status
   FROM form_view
   WHERE id = {form_view_id};
   ```
2. **状态判断处理**

   **2.1 状态为 1-理解中**

   返回错误响应：

   ```json
   {
     "code": 400,
     "message": "当前正在理解中，请稍后再试",
     "data": {
       "error_type": "understanding_in_progress",
       "understand_status": 1
     }
   }
   ```

   **2.2 状态为 0-未理解、3-已完成、4-已发布**

   从正式表查询数据：

   ```sql
   -- 查询业务对象列表
   SELECT
     bo.id AS object_id,
     bo.uuid AS object_uuid,
     bo.object_name
   FROM t_business_object bo
   WHERE bo.form_view_id = {form_view_id}
     AND bo.deleted_at IS NULL
   ORDER BY bo.id ASC;

   -- 查询业务对象属性（带字段信息）
   SELECT
     boa.id AS attribute_id,
     boa.business_object_id,
     boa.attr_name,
     boa.form_view_field_id,
     fvf.technical_name AS field_tech_name,
     fvf.data_type AS field_type,
     fvf.field_business_name,
     fvf.field_role
   FROM t_business_object_attributes boa
   JOIN form_view_field fvf
     ON boa.form_view_field_id = fvf.id
     AND fvf.deleted_at IS NULL
   WHERE boa.form_view_id = {form_view_id}
     AND boa.deleted_at IS NULL
   ORDER BY boa.id ASC;
   ```

   **2.3 状态为 2-待确认**

   从临时表获取业务对象和属性信息，字段基本信息（技术名称、字段类型）从正式表获取：

   ```sql
   -- 获取当前版本号
   SELECT COALESCE(MAX(version), 10) AS current_version
   FROM t_business_object_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;

   -- 查询业务对象列表
   SELECT
     bot.id AS object_id,
     bot.uuid AS object_uuid,
     bot.object_name
   FROM t_business_object_temp bot
   WHERE bot.form_view_id = {form_view_id}
     AND bot.version = {current_version}
     AND bot.deleted_at IS NULL
   ORDER BY bot.id ASC;

   -- 查询业务对象属性（带字段信息）
   SELECT
     boattr.id AS attribute_id,
     boattr.business_object_id,
     boattr.attr_name,
     boattr.form_view_field_id,
     fvf.technical_name AS field_tech_name,
     fvf.data_type AS field_type,
     COALESCE(fvfit.field_business_name, fvf.field_business_name) AS field_business_name,
     COALESCE(fvfit.field_role, fvf.field_role) AS field_role
   FROM t_business_object_attributes_temp boattr
   JOIN form_view_field fvf
     ON boattr.form_view_field_id = fvf.id
     AND fvf.deleted_at IS NULL
   LEFT JOIN t_form_view_field_info_temp fvfit
     ON fvf.id = fvfit.form_view_field_id
     AND fvfit.version = {current_version}
     AND fvfit.deleted_at IS NULL
   WHERE boattr.form_view_id = {form_view_id}
     AND boattr.version = {current_version}
     AND boattr.deleted_at IS NULL
   ORDER BY boattr.id ASC;
   ```
3. **参数过滤处理**

   **3.1 object_id 不为空时，只返回指定业务对象**

   ```sql
   -- 添加 WHERE 条件
   AND bo.id = {object_id}  -- 正式表
   -- 或
   AND bot.id = {object_id} -- 临时表
   ```

   **3.2 keyword 不为空时，模糊匹配属性名称/字段业务名称**

   *状态为 0-未理解、3-已完成、4-已发布时（查询正式表）：*

   ```sql
   -- 在 WHERE 子句中添加条件
   AND (
     boa.attr_name LIKE CONCAT('%', {keyword}, '%')
     OR fvf.field_business_name LIKE CONCAT('%', {keyword}, '%')
   )
   ```

   *状态为 2-待确认时（查询临时表）：*

   ```sql
   -- 在 WHERE 子句中添加条件
   AND (
     boattr.attr_name LIKE CONCAT('%', {keyword}, '%')
     OR COALESCE(fvfit.field_business_name, fvf.field_business_name) LIKE CONCAT('%', {keyword}, '%')
   )
   ```
4. **组装返回数据**

   将业务对象和属性数据组装成嵌套结构：

   - 遍历业务对象列表
   - 对每个业务对象，查找其关联的属性列表
   - 返回嵌套的 JSON 结构

**数据来源说明**：

根据 `understand_status` 状态决定数据来源：

| 状态     | 业务对象 | 属性   | 字段业务信息   | 字段基本信息    |
| -------- | -------- | ------ | -------------- | --------------- |
| 0-未理解 | 正式表   | 正式表 | 正式表         | form_view_field |
| 1-理解中 | 禁止调用 | -      | -              | -               |
| 2-待确认 | 临时表   | 临时表 | 临时表（优先） | form_view_field |
| 3-已完成 | 正式表   | 正式表 | 正式表         | form_view_field |
| 4-已发布 | 正式表   | 正式表 | 正式表         | form_view_field |

- `object_name`、`id`：状态0/3/4来自正式表，状态2来自临时表
- `attr_name`、`id`（属性ID）：状态0/3/4来自正式表，状态2来自临时表
- `field_tech_name`、`field_type`：始终来自 `form_view_field` 表
- `field_business_name`、`field_role`：状态0/3/4来自正式表，状态2临时表优先
- `current_version`：状态2时返回当前版本号，其他状态返回 0

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "data": {
    "current_version": 10,                     // int - 当前版本号（存储格式：10=1.0，显示时除以10）
    "list": [                              // 业务对象列表
      {
        "id": "uuid-xxx",                  // string - 业务对象ID（临时表UUID）
        "object_name": "基础信息",             // string - 业务对象名称
        "attributes": [                       // 属性列表
          {
            "id": "uuid-xxx",              // string - 属性ID（临时表UUID）
            "attr_name": "姓名",              // string - 属性名称
            "form_view_field_id": "xxx",      // string - 关联字段UUID
            "field_tech_name": "name",        // string - 字段技术名称（来自 form_view_field.technical_name）
            "field_business_name": "姓名",     // string - 字段业务名称
            "field_role": 6,                  // int - 字段角色（1-业务主键, 2-关联标识, 3-业务状态, 4-时间字段, 5-业务指标, 6-业务特征, 7-审计字段, 8-技术字段）
            "field_type": "字符型"             // string - 字段类型（来自 form_view_field.data_type）
          },
          {
            "id": "uuid-yyy",
            "attr_name": "身份证",
            "form_view_field_id": "yyy",
            "field_tech_name": "id_card",
            "field_business_name": "身份证号码",
            "field_role": 1,
            "field_type": "字符型"
          }
        ]
      },
      {
        "id": "uuid-yyy",
        "object_name": "出生信息",
        "attributes": [
          {
            "id": "uuid-zzz",
            "attr_name": "出生日期",
            "form_view_field_id": "zzz",
            "field_tech_name": "birth_date",
            "field_business_name": "出生日期",
            "field_role": 4,
            "field_type": "日期型"
          }
        ]
      },
      {
        "id": "uuid-zzz",
        "object_name": "联系方式",
        "attributes": [
          {
            "id": "uuid-aaa",
            "attr_name": "手机号",
            "form_view_field_id": "aaa",
            "field_tech_name": "phone",
            "field_business_name": "手机号码",
            "field_role": 6,
            "field_type": "字符型"
          }
        ]
      }
    ]
  }
}
```

---

#### 4.3.3 提交理解数据

**接口路径**：`POST /api/v1/data-semantic/{id}/submit`

**请求参数**：

| 参数名 | 类型   | 必填 | 说明         |
| ------ | ------ | ---- | ------------ |
| id     | string | 是   | 数据视图UUID |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**并发控制**：同一用户对同一库表1秒内只允许点击一次，使用 Redis 限流，Key 格式为 `库表UUID:用户ID`。

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：数据尚未生成，不允许提交
   - `1-理解中`：正在生成数据，不允许提交
   - `2-待确认`：允许提交
   - `3-已完成`：允许提交（同步临时表数据到正式表）
   - `4-已发布`：已发布，不允许重新提交
2. **检查临时表数据并同步**

   2.1 **检查库表信息临时表是否有数据**

   ```sql
   SELECT COUNT(*) AS count
   FROM t_form_view_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

   - 如果有数据：获取当前版本号并同步到正式表
   - 如果无数据：跳过库表信息同步

   2.2 **检查字段信息临时表是否有数据**

   ```sql
   SELECT COUNT(*) AS count
   FROM t_form_view_field_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

   - 如果有数据：获取当前版本号并同步到正式表
   - 如果无数据：跳过字段信息同步
3. **使用数据库事务执行数据同步**

   **事务开始：**

   3.1 **同步库表信息到正式表（如果临时表有数据）**

   ```sql
   UPDATE form_view fv
   JOIN t_form_view_info_temp fvit ON fv.id = fvit.form_view_id
   SET
     fv.business_name = COALESCE(fvit.table_business_name, fv.business_name),
     fv.description = COALESCE(fvit.table_description, fv.description)
   WHERE fv.id = {form_view_id}
     AND fvit.version = {current_version}
     AND fvit.deleted_at IS NULL;
   ```

   3.2 **同步字段信息到正式表（如果临时表有数据）**

   ```sql
   UPDATE form_view_field fvf
   JOIN t_form_view_field_info_temp fvfit ON fvf.id = fvfit.form_view_field_id
   SET
     fvf.field_business_name = COALESCE(fvfit.field_business_name, fvf.field_business_name),
     fvf.field_role = COALESCE(fvfit.field_role, fvf.field_role),
     fvf.field_description = COALESCE(fvfit.field_description, fvf.field_description)
   WHERE fvf.form_view_id = {form_view_id}
     AND fvfit.version = {current_version}
     AND fvfit.deleted_at IS NULL;
   ```

   3.3 **增量同步业务对象数据到正式表**

   **设计说明**：采用增量更新策略，保留正式表记录的 ID 稳定性，避免外部引用失效。

   **3.3.1 处理有 formal_id 的临时表记录（更新正式表）**

   ```sql
   -- 更新已存在的业务对象
   UPDATE t_business_object bo
   JOIN t_business_object_temp bot ON bo.id = bot.formal_id
   SET
     bo.object_name = bot.object_name,
     bo.updated_at = NOW(3)
   WHERE bot.form_view_id = {form_view_id}
     AND bot.version = {current_version}
     AND bot.formal_id IS NOT NULL
     AND bot.deleted_at IS NULL;
   ```

   **3.3.2 处理无 formal_id 的临时表记录（新增到正式表）**

   ```sql
   -- 新增业务对象（生成新 ID）
   INSERT INTO t_business_object (
     id, object_name, object_type, form_view_id, status, created_at, updated_at
   )
   SELECT
     bot.id, bot.object_name, 1 AS object_type, bot.form_view_id, 1 AS status,
     NOW(3), NOW(3)
   FROM t_business_object_temp bot
   WHERE bot.form_view_id = {form_view_id}
     AND bot.version = {current_version}
     AND bot.formal_id IS NULL
     AND bot.deleted_at IS NULL;
   ```

   **3.3.3 删除正式表中不再存在的业务对象**

   ```sql
   -- 逻辑删除正式表中有但临时表中没有的业务对象
   UPDATE t_business_object bo
   SET deleted_at = NOW(3)
   WHERE bo.form_view_id = {form_view_id}
     AND bo.deleted_at IS NULL
     AND bo.id NOT IN (
       SELECT formal_id FROM t_business_object_temp
       WHERE form_view_id = {form_view_id}
         AND version = {current_version}
         AND formal_id IS NOT NULL
         AND deleted_at IS NULL
     );
   ```

   **3.3.4 更新临时表的 formal_id（为下次提交准备）**

   ```sql
   -- 将新增记录的正式表 ID 回写到临时表
   UPDATE t_business_object_temp bot
   JOIN t_business_object bo ON bot.id = bo.id
   SET bot.formal_id = bo.id
   WHERE bot.form_view_id = {form_view_id}
     AND bot.version = {current_version}
     AND bot.formal_id IS NULL
     AND bot.deleted_at IS NULL;
   ```

   3.4 **增量同步业务对象属性数据到正式表**

   **3.4.1 处理有 formal_id 的临时表属性记录（更新正式表）**

   ```sql
   -- 更新已存在的属性
   UPDATE t_business_object_attributes boa
   JOIN t_business_object_attributes_temp boat ON boa.id = boat.formal_id
   SET
     boa.attr_name = boat.attr_name,
     boa.updated_at = NOW(3)
   WHERE boat.form_view_id = {form_view_id}
     AND boat.version = {current_version}
     AND boat.formal_id IS NOT NULL
     AND boat.deleted_at IS NULL;
   ```

   **3.4.2 处理无 formal_id 的临时表属性记录（新增到正式表）**

   ```sql
   -- 新增属性
   INSERT INTO t_business_object_attributes (
     id, form_view_id, business_object_id, form_view_field_id, attr_name, created_at, updated_at
   )
   SELECT
     boat.id, boat.form_view_id, bo.id AS business_object_id,
     boat.form_view_field_id, boat.attr_name, NOW(3), NOW(3)
   FROM t_business_object_attributes_temp boat
   JOIN t_business_object_temp bot ON boat.business_object_id = bot.id
   JOIN t_business_object bo ON bot.formal_id = bo.id
   WHERE boat.form_view_id = {form_view_id}
     AND boat.version = {current_version}
     AND boat.formal_id IS NULL
     AND boat.deleted_at IS NULL;
   ```

   **3.4.3 删除正式表中不再存在的属性**

   ```sql
   -- 逻辑删除正式表中有但临时表中没有的属性
   UPDATE t_business_object_attributes boa
   SET deleted_at = NOW(3)
   WHERE boa.form_view_id = {form_view_id}
     AND boa.deleted_at IS NULL
     AND boa.id NOT IN (
       SELECT formal_id FROM t_business_object_attributes_temp
       WHERE form_view_id = {form_view_id}
         AND version = {current_version}
         AND formal_id IS NOT NULL
         AND deleted_at IS NULL
     );
   ```

   **3.4.4 更新临时表属性的 formal_id**

   ```sql
   -- 将新增记录的正式表 ID 回写到临时表
   UPDATE t_business_object_attributes_temp boat
   JOIN t_business_object_attributes boa ON boat.id = boa.id
   SET boat.formal_id = boa.id
   WHERE boat.form_view_id = {form_view_id}
     AND boat.version = {current_version}
     AND boat.formal_id IS NULL
     AND boat.deleted_at IS NULL;
   ```

   3.6 **更新理解状态**

   ```sql
   UPDATE form_view
   SET understand_status = 3
   WHERE id = {form_view_id};
   ```

   **事务提交**

   **异常处理**：如果任何步骤失败，回滚所有已执行的操作
4. **返回提交成功响应**

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "message": "提交成功",                        // string - 响应消息
  "data": {
    "understand_status": 3                    // int - 理解状态（0-未理解,1-理解中,2-待确认,3-已完成,4-已发布）
  }
}
```

**状态校验失败响应**：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "当前状态不允许提交",               // string - 响应消息
  "data": {
    "error_type": "invalid_status",           // string - 错误类型
    "current_status": 0,                      // int - 当前理解状态
    "allowed_status": [2, 3]                  // array - 允许提交的状态（2-待确认, 3-已完成）
  }
}
```

---

#### 4.3.4 删除业务对象识别结果

**接口路径**：`DELETE /api/v1/data-semantic/{id}/business-objects`

**请求参数**：

| 参数名 | 类型   | 必填 | 说明         |
| ------ | ------ | ---- | ------------ |
| id     | string | 是   | 数据视图UUID |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**并发控制**：同一用户对同一库表1秒内只允许点击一次，使用 Redis 限流，Key 格式为 `库表UUID:用户ID`。

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：没有数据可删除
   - `1-理解中`：正在生成数据，不允许删除
   - `2-待确认`：允许删除
   - `3-已完成`：已完成理解，不允许删除
   - `4-已发布`：已发布，不允许删除
2. **检查是否存在业务对象临时数据**

   ```sql
   SELECT COUNT(*) AS count
   FROM t_business_object_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

   如果 count = 0，提示"没有可删除的数据"
3. **使用数据库事务执行删除操作**

   **事务开始：**

   3.1 **逻辑删除业务对象临时数据**

   ```sql
   UPDATE t_business_object_temp
   SET deleted_at = NOW(3)
   WHERE form_view_id = {form_view_id}
     AND deleted_at IS NULL;
   ```

   3.2 **逻辑删除业务对象属性临时数据**

   ```sql
   UPDATE t_business_object_attributes_temp
   SET deleted_at = NOW(3)
   WHERE form_view_id = {form_view_id}
     AND deleted_at IS NULL;
   ```

   3.3 **检查正式表是否有业务对象数据，决定最终状态**

   ```sql
   -- 检查正式表是否有业务对象
   SELECT COUNT(*) AS object_count
   FROM t_business_object
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

   - 如果 `object_count > 0`：保持 `3-已完成`
   - 如果 `object_count = 0`：更新为 `0-未理解`

   ```sql
   -- 根据是否有正式数据更新状态
   UPDATE form_view
   SET understand_status = CASE
     WHEN (SELECT COUNT(*) FROM t_business_object WHERE form_view_id = {form_view_id} AND deleted_at IS NULL) > 0
       THEN 3  -- 保持已完成
     ELSE 0    -- 回退到未理解
   END
   WHERE id = {form_view_id};
   ```

   **事务提交**
4. **说明**：

   - `t_form_view_info_temp` 和 `t_form_view_field_info_temp` 数据**保留**，不删除
   - 删除后根据正式表是否有数据决定最终状态：
     - 有正式数据 → `3-已完成`
     - 无正式数据 → `0-未理解`
   - 如果需要重新生成，需要调用接口6重新生成数据

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "message": "删除成功",                        // string - 响应消息
  "data": {
    "understand_status": 3                    // int - 删除后的理解状态（0-未理解 或 3-已完成，取决于正式表是否有数据）
  }
}
```

**状态校验失败响应**：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "当前状态不允许删除",               // string - 响应消息
  "data": {
    "error_type": "invalid_status",           // string - 错误类型
    "current_status": 3,                      // int - 当前理解状态
    "allowed_status": [2]                     // array - 允许删除的状态（2-待确认）
  }
}
```

---

#### 4.3.5 重新识别业务对象

**接口路径**：`POST /api/v1/data-semantic/{id}/business-objects/regenerate`

**请求参数**：

| 参数名 | 类型   | 必填 | 说明         |
| ------ | ------ | ---- | ------------ |
| id     | string | 是   | 数据视图UUID |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**并发控制**：同一用户对同一库表1秒内只允许点击一次，使用 Redis 限流，Key 格式为 `库表UUID:用户ID`。

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：请先使用接口6生成数据
   - `1-理解中`：正在生成数据，请等待完成
   - `2-待确认`：允许重新识别
   - `3-已完成`：允许重新识别（基于当前字段语义数据）
   - `4-已发布`：已发布，无法修改
2. **获取 form_view 数据（库表和字段信息）**

   **2.1 获取库表基础信息**

   ```sql
   SELECT
     id AS form_view_id,
     technical_name AS form_view_technical_name,
     business_name AS form_view_business_name,
     description AS form_view_desc
   FROM form_view
   WHERE id = {form_view_id} AND deleted_at IS NULL;
   ```

   **2.2 获取当前版本号**

   ```sql
   SELECT COALESCE(MAX(version), 10) AS current_version
   FROM t_form_view_field_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

   **2.3 获取字段信息（技术信息 + 语义信息）**

   ```sql
   -- 获取字段技术信息
   SELECT
     fvf.id AS form_view_field_id,
     fvf.technical_name AS form_view_field_technical_name,
     fvf.data_type AS form_view_field_type,
     COALESCE(fvfit.field_business_name, fvf.field_business_name) AS form_view_field_business_name,
     COALESCE(fvfit.field_role, fvf.field_role) AS form_view_field_role,
     COALESCE(fvfit.field_description, fvf.field_description) AS form_view_field_desc
   FROM form_view_field fvf
   LEFT JOIN t_form_view_field_info_temp fvfit
     ON fvf.id = fvfit.form_view_field_id
     AND fvfit.version = {current_version}
     AND fvfit.deleted_at IS NULL
   WHERE fvf.form_view_id = {form_view_id}
     AND fvf.deleted_at IS NULL
   ORDER BY fvf.`index` ASC;
   ```
3. **调用 AI 服务重新识别业务对象**

   调用 AI 服务 HTTP API：

   **接口地址**：`/api/af-sailor-agent/v1/data_understand/view_semantic_and_business_analysis`

   **请求方式**：POST

   **请求体**：

   ```json
   {
     "message_id": "uuid-xxx",
     "request_type": "regenerate_business_objects",
     "form_view": {
       "form_view_id": "form-view-uuid",
       "form_view_technical_name": "cowenrr",
       "form_view_business_name": "员工信息表",
       "form_view_desc": "员工基础信息表",
       "form_view_fields": [
         {
           "form_view_field_id": "field-uuid-1",
           "form_view_field_technical_name": "name",
           "form_view_field_business_name": "姓名",
           "form_view_field_type": "VARCHAR",
           "form_view_field_role": "2",
           "form_view_field_desc": "人员姓名"
         }
       ]
     }
   }
   ```

   **响应**：接口立即返回"任务处理中"（不等待AI处理完成）

   **响应体结构**：
   ```json
   {
     "task_id": "string",
     "status": "pending|running|completed|failed|cancelled",
     "message": "string",
     "message_id": "string"
   }
   ```

   **异常判断**：
   - HTTP 响应码 ≠ 200 → 提示"服务异常，请稍后再试"，状态保持 `1-理解中`
   - HTTP 响应码 = 200 且 status = "failed" → 提示"服务异常，请稍后再试"，状态保持 `1-理解中`
   - HTTP 响应码 = 200 且 status ≠ "failed" → 正常，AI 服务异步处理中，状态保持 `1-理解中`

   **说明**：无论 AI 服务调用成功与否，状态都保持 `1-理解中`，由 Kafka 消费者处理完成后更新为 `2-待确认`（成功）或 `5-理解失败`（失败）。

4. **AI 服务异步处理完成后的结果**

   AI 服务处理完成后，写入 Kafka 消息到 `data-understanding-responses` 主题：    

   **成功时的响应**：
   ```json
   {
     "message_id": "uuid-xxx",
     "form_view_id": "form-view-uuid",
     "request_type": "regenerate_business_objects",
     "status": "success",
     "process_time": "2026-01-30T10:00:05.000Z",
     "data": {
       "table_semantic": {
         "table_business_name": "员工信息表",
         "table_description": "用于存储员工的基础信息，包括姓名、身份证、联系方式等"
       },
       "fields_semantic": [
         {
           "form_view_field_id": "field-uuid-1",
           "field_business_name": "员工ID",
           "field_role": 1,
           "field_description": "员工唯一标识"
         },
         {
           "form_view_field_id": "field-uuid-2",
           "field_business_name": "员工姓名",
           "field_role": 2,
           "field_description": "员工真实姓名"
         }
       ],
       "no_pattern_fields": [
         {
           "form_view_field_id": "field-uuid-1",
           "field_business_name": "员工ID",
           "field_role": 1,
           "field_description": "员工唯一标识"
         }
       ],
       "business_objects": [
         {
           "object_name": "基础信息",
           "attributes": [
             {
               "form_view_field_id": "xxx",
               "attr_name": "姓名"
             }
           ]
         }
       ]
     }
   }
   ```

   **失败时的响应**：
   ```json
   {
     "message_id": "uuid-xxx",
     "form_view_id": "form-view-uuid",
     "request_type": "regenerate_business_objects",
     "status": "failed",
     "process_time": "2026-01-30T10:00:05.000Z",
     "error": {
       "code": "AI_SERVICE_ERROR",
       "message": "AI 服务处理失败的具体原因"
     }
   }
   ```
5. **Kafka 消费者处理 AI 返回结果**

   数据保存和状态更新由 Kafka 消费者处理（详见 **6. Kafka 消费者处理流程**），包括：
   - 保存 `table_semantic` 到 `t_form_view_info_temp`
   - 保存 `fields_semantic` 到 `t_form_view_field_info_temp`
   - 保存 `no_pattern_fields` 到 `t_form_view_field_info_temp`
   - 保存 `business_objects` 到 `t_business_object_temp` 和 `t_business_object_attributes_temp`
   - 更新 `understand_status` 为 `2-待确认`（成功）或 `5-理解失败`（失败）

6. **说明**：

   - 接口调用成功后立即返回，不等待 AI 处理完成
   - AI 服务异步处理，完成后将结果写入 Kafka
   - Kafka 消费者订阅 `data-understanding-responses` 主题处理结果
   - 消费者会校验库表状态是否为 `1-理解中`，防止处理过期消息
   - 旧版本记录保留，通过版本号区分，新版本记录的 `user_id` 为 NULL 表示 AI 模型操作

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "message": "重新生成成功",                    // string - 响应消息
  "data": {
    "object_count": 2,                       // int - 业务对象数量
    "attribute_count": 10                    // int - 属性数量
  }
}
```

**状态校验失败响应**：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "当前状态不允许重新识别",           // string - 响应消息
  "data": {
    "error_type": "invalid_status",           // string - 错误类型
    "current_status": 0,                      // int - 当前理解状态
    "allowed_status": [2, 3]                  // array - 允许重新识别的状态（2-待确认, 3-已完成）
  }
}
```

---

#### 4.3.6 一键生成理解数据

**接口路径**：`POST /api/v1/data-semantic/{id}/generate`

**请求参数**：

| 参数名 | 类型   | 必填 | 说明         |
| ------ | ------ | ---- | ------------ |
| id     | string | 是   | 数据视图UUID |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**并发控制**：同一用户对同一库表1秒内只允许点击一次，使用 Redis 限流，Key 格式为 `库表UUID:用户ID`。

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：允许生成
   - `1-理解中`：正在生成中，不允许重复生成
   - `2-待确认`：已有数据，请先删除或提交
   - `3-已完成`：允许重新生成
   - `4-已发布`：已发布，无法修改
   - `5-理解失败`：允许重新生成
2. **【立即同步更新】修改 form_view 表中 understand_status 字段为 `1-理解中`**

   ```sql
   UPDATE form_view
   SET understand_status = 1
   WHERE id = {form_view_id};
   ```

   **执行时机**：在状态校验通过后、启动AI任务前，立即同步更新数据库

   **更新目的**：

   - 标识库表正在被AI分析，防止重复点击
   - 前端轮询可感知到状态变化，展示"理解中"提示
3. **收集 form_view 数据（库表和字段信息）**

   ```sql
   -- 获取库表基础信息
   SELECT
     id AS form_view_id,
     technical_name AS form_view_technical_name,
     business_name AS form_view_business_name,
     description AS form_view_desc
   FROM form_view
   WHERE id = {form_view_id} AND deleted_at IS NULL;

   -- 获取字段基础信息
   SELECT
     id AS form_view_field_id,
     technical_name AS form_view_field_technical_name,
     business_name AS form_view_field_business_name,
     data_type AS form_view_field_type,
     field_role AS form_view_field_role,
     field_description AS form_view_field_desc
   FROM form_view_field
   WHERE form_view_id = {form_view_id}
     AND deleted_at IS NULL
   ORDER BY `index` ASC;
   ```
4. **获取新版本号**

   ```sql
   SELECT COALESCE(MAX(version), 10) + 1 AS new_version
   FROM t_form_view_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```
5. **调用 AI 服务执行分析任务**

   **5.1 调用 AI 服务 HTTP API**

   **接口地址**：`/api/af-sailor-agent/v1/data_understand/view_semantic_and_business_analysis`

   **请求方式**：POST

   **请求体**：

   ```json
   {
     "message_id": "uuid-request-xxx",
     "request_type": "full_understanding",
     "form_view": {
       "form_view_id": "form-view-uuid",
       "form_view_technical_name": "cowenrr",
       "form_view_business_name": "员工信息表",
       "form_view_desc": "员工基础信息表",
       "form_view_fields": [
         {
           "form_view_field_id": "field-uuid-1",
           "form_view_field_technical_name": "id",
           "form_view_field_business_name": "ID",
           "form_view_field_type": "BIGINT",
           "form_view_field_role": "1",
           "form_view_field_desc": "主键ID"
         },
         {
           "form_view_field_id": "field-uuid-2",
           "form_view_field_technical_name": "name",
           "form_view_field_business_name": "姓名",
           "form_view_field_type": "VARCHAR",
           "form_view_field_role": "2",
           "form_view_field_desc": "员工姓名"
         }
       ]
     }
   }
   ```

   **响应**：接口立即返回"任务处理中"（不等待AI处理完成）

   **响应体结构**：
   ```json
   {
     "task_id": "string",
     "status": "pending|running|completed|failed|cancelled",
     "message": "string",
     "message_id": "string"
   }
   ```

   **异常判断**：
   - HTTP 响应码 ≠ 200 → 提示"服务异常，请稍后再试"，状态保持 `1-理解中`
   - HTTP 响应码 = 200 且 status = "failed" → 提示"服务异常，请稍后再试"，状态保持 `1-理解中`
   - HTTP 响应码 = 200 且 status ≠ "failed" → 正常，AI 服务异步处理中，状态保持 `1-理解中`

   **说明**：无论 AI 服务调用成功与否，状态都保持 `1-理解中`，由 Kafka 消费者处理完成后更新为 `2-待确认`（成功）或 `5-理解失败`（失败）。

   **5.2 AI 服务异步处理完成后的结果**

   AI 服务处理完成后，写入 Kafka 消息到 `data-understanding-responses` 主题：

   **成功时的响应**：
   ```json
   {
     "message_id": "uuid-request-xxx",
     "form_view_id": "form-view-uuid",
     "request_type": "full_understanding",
     "status": "success",
     "process_time": "2026-01-30T10:00:05.000Z",
     "data": {
       "table_semantic": {
         "table_business_name": "员工信息表",
         "table_description": "用于存储员工的基础信息，包括姓名、身份证、联系方式等"
       },
       "fields_semantic": [
         {
           "form_view_field_id": "field-uuid-1",
           "field_business_name": "员工ID",
           "field_role": 1,
           "field_description": "员工唯一标识"
         },
         {
           "form_view_field_id": "field-uuid-2",
           "field_business_name": "员工姓名",
           "field_role": 2,
           "field_description": "员工真实姓名"
         }
       ],
       "no_pattern_fields": [
         {
           "form_view_field_id": "field-uuid-1",
           "field_business_name": "员工ID",
           "field_role": 1,
           "field_description": "员工唯一标识"
         }
       ],
       "business_objects": [
         {
           "object_name": "基础信息",
           "attributes": [
             {
               "form_view_field_id": "field-uuid-2",
               "attr_name": "姓名"
             },
             {
               "form_view_field_id": "field-uuid-3",
               "attr_name": "身份证"
             }
           ]
         },
         {
           "object_name": "联系方式",
           "attributes": [
             {
               "form_view_field_id": "field-uuid-4",
               "attr_name": "手机号"
             }
           ]
         }
       ]
     }
   }
   ```

   **失败时的响应**：
   ```json
   {
     "message_id": "uuid-request-xxx",
     "form_view_id": "form-view-uuid",
     "request_type": "full_understanding",
     "status": "failed",
     "process_time": "2026-01-30T10:00:05.000Z",
     "error": {
       "code": "AI_SERVICE_ERROR",
       "message": "AI 服务处理失败的具体原因"
     }
   }
   ```

6. **Kafka 消费者处理 AI 返回结果**

   数据保存和状态更新由 Kafka 消费者处理（详见 **7. Kafka 消费者处理流程**），包括：
   - 保存 `table_semantic` 到 `t_form_view_info_temp`
   - 保存 `fields_semantic` 到 `t_form_view_field_info_temp`
   - 保存 `no_pattern_fields` 到 `t_form_view_field_info_temp`
   - 保存 `business_objects` 到 `t_business_object_temp` 和 `t_business_object_attributes_temp`
   - 更新 `understand_status` 为 `2-待确认`（成功）或 `5-理解失败`（失败）

7. **Kafka 消费者处理流程**

   **7.1 Kafka 消费者处理逻辑**

   - 主题：`data-understanding-responses`
   - 消费者组：`data-understanding-consumer-group`
   - 自动提交：关闭（手动处理完成后提交）

   **7.2 数据保存逻辑**（成功响应时）

   获取新版本号：
   ```sql
   SELECT COALESCE(MAX(version), 10) + 1 AS new_version
   FROM t_form_view_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

   **7.2.1 保存库表信息到 t_form_view_info_temp**

   ```sql
   INSERT INTO t_form_view_info_temp (
     id, form_view_id, user_id, version, table_business_name, table_description,
     created_at, updated_at, deleted_at
   )
   VALUES (
     {uuid}, {form_view_id}, NULL, {new_version},
     '员工信息表', '用于存储员工的基础信息，包括姓名、身份证、联系方式等',
     NOW(3), NOW(3), NULL
   );
   ```

   **7.2.2 保存字段信息到 t_form_view_field_info_temp**

   ```sql
   INSERT INTO t_form_view_field_info_temp (
     id, form_view_id, form_view_field_id, user_id, version,
     field_business_name, field_role, field_description,
     created_at, updated_at, deleted_at
   )
   VALUES
     ({uuid_1}, {form_view_id}, 'field-uuid-1', NULL, {new_version},
      '员工ID', 1, '员工唯一标识', NOW(3), NOW(3), NULL),
     ({uuid_2}, {form_view_id}, 'field-uuid-2', NULL, {new_version},
      '员工姓名', 2, '员工真实姓名', NOW(3), NOW(3), NULL);
   ```

   **7.2.3 保存业务对象到 t_business_object_temp**

   ```sql
   INSERT INTO t_business_object_temp (
     id, form_view_id, user_id, version, object_name,
     created_at, updated_at, deleted_at
   )
   VALUES
     ({uuid_1}, {form_view_id}, NULL, {new_version}, '基础信息',
      NOW(3), NOW(3), NULL),
     ({uuid_2}, {form_view_id}, NULL, {new_version}, '联系方式',
      NOW(3), NOW(3), NULL);
   ```

   **7.2.4 保存业务对象属性到 t_business_object_attributes_temp**

   ```sql
   INSERT INTO t_business_object_attributes_temp (
     id, form_view_id, business_object_id, user_id, version,
     form_view_field_id, attr_name,
     created_at, updated_at, deleted_at
   )
   VALUES
     ({uuid_1}, {form_view_id}, {uuid_1}, NULL, {new_version}, 'field-uuid-2', '姓名',
      NOW(3), NOW(3), NULL),
     ({uuid_2}, {form_view_id}, {uuid_1}, NULL, {new_version}, 'field-uuid-3', '身份证',
      NOW(3), NOW(3), NULL),
     ({uuid_3}, {form_view_id}, {uuid_2}, NULL, {new_version}, 'field-uuid-4', '手机号',
      NOW(3), NOW(3), NULL);
   ```

   **7.2.5 保存未识别字段到 t_business_object_attributes_temp**

   对于 `no_pattern_fields`（AI 未识别出属性和对象的字段），保存到同一张表但标记为未归属：

   ```sql
   INSERT INTO t_business_object_attributes_temp (
     id, form_view_id, business_object_id, user_id, version,
     form_view_field_id, attr_name,
     created_at, updated_at, deleted_at
   )
   VALUES
     ({uuid_4}, {form_view_id}, NULL, NULL, {new_version}, 'field-uuid-5', NULL,
      NOW(3), NOW(3), NULL);
   ```

   **说明**：
   - `business_object_id = NULL`：表示未归属任何业务对象
   - `attr_name = NULL`：表示未分配属性名
   - 查询接口可通过 `business_object_id IS NULL` 筛选出未识别字段

   **7.3 消费者处理代码**

   ```java
   @KafkaListener(topics = "data-understanding-responses", groupId = "data-understanding-consumer-group")
   public void handleAIResponse(String message) {
       // 1. 解析 Kafka 消息
       AIResponse response = JSON.parseObject(message, AIResponse.class);

       // 2. 校验 message_id 是否存在且未处理（防止重复消费）
       if (isMessageProcessed(response.getMessageId())) {
           log.warn("消息已处理，跳过: {}", response.getMessageId());
           return;
       }

       // 3. 校验库表当前理解状态（必须是 1-理解中 才处理）
       int currentStatus = getUnderstandStatus(response.getFormViewId());
       if (currentStatus != 1) {
           log.warn("库表理解状态不是1-理解中，跳过处理: form_view_id={}, current_status={}",
               response.getFormViewId(), currentStatus);
           // 标记消息已处理（不处理）
           markMessageAsProcessed(response.getMessageId(), 1);
           return;
       }

       // 4. 根据 status 字段判断成功或失败
       if ("success".equals(response.getStatus())) {
           // 4.1 成功：保存数据到临时表，更新状态为 2-待确认
           try {
               transactionTemplate.execute(status -> {
                   saveTableSemantic(response.getFormViewId(), response.getData().getTableSemantic());
                   saveFieldsSemantic(response.getFormViewId(), response.getData().getFieldsSemantic());
                   saveNoPatternFields(response.getFormViewId(), response.getData().getNoPatternFields());
                   saveBusinessObjects(response.getFormViewId(), response.getData().getBusinessObjects());
                   return null;
               });

               // 更新 understand_status 为 2-待确认
               updateUnderstandStatus(response.getFormViewId(), 2);

               // 标记消息已处理
               markMessageAsProcessed(response.getMessageId(), 1);

           } catch (Exception e) {
               log.error("处理 AI 响应失败: {}", response.getMessageId(), e);
               // 标记消息处理失败
               markMessageAsProcessed(response.getMessageId(), 2);
               // understand_status 保持为 1-理解中
           }
       } else {
           // 4.2 失败：记录错误日志，更新状态为 5-理解失败
           log.error("AI 处理失败: message_id={}, error={}",
               response.getMessageId(), response.getError().getMessage());

           // 更新 understand_status 为 5-理解失败
           updateUnderstandStatus(response.getFormViewId(), 5);

           // 标记消息已处理（失败）
           markMessageAsProcessed(response.getMessageId(), 2, response.getError().getMessage());
       }
   }
   ```

   **7.3.1 saveNoPatternFields 方法说明**

   ```java
   /**
    * 保存未识别字段到业务对象属性临时表
    * 这些字段未被 AI 识别并分配到任何业务对象
    *
    * @param formViewId 数据视图ID
    * @param noPatternFields 未识别字段列表
    */
   private void saveNoPatternFields(String formViewId, List<NoPatternField> noPatternFields) {
       for (NoPatternField field : noPatternFields) {
           // business_object_id = NULL (未归属任何业务对象)
           // attr_name = NULL (未分配属性名)
           insertUnrecognizedAttribute(formViewId, field.getFormViewFieldId());
       }
   }
   ```

   **防止重复消费机制**：

   ```sql
   -- 创建消息处理记录表
   CREATE TABLE IF NOT EXISTS t_kafka_message_log (
       id CHAR(36) NOT NULL COMMENT '主键UUID',
       message_id CHAR(36) NOT NULL COMMENT 'Kafka消息ID',
       form_view_id CHAR(36) NOT NULL COMMENT '关联数据视图UUID',
       processed_at DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3) COMMENT '处理时间',
       status TINYINT DEFAULT 1 COMMENT '状态：1-处理成功，2-处理失败',
       error_msg TEXT COMMENT '错误信息',
       PRIMARY KEY (id),
       UNIQUE KEY uk_message_id (message_id),
       KEY idx_form_view_id (form_view_id)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Kafka消息处理记录表';
   ```
9. **异常处理**

   | 异常场景          | 处理方式                                                  | understand_status   |
   | ----------------- | --------------------------------------------------------- | ------------------- |
   | HTTP API调用失败  | HTTP响应码≠200，或HTTP=200但status=failed，提示"服务异常，请稍后再试" | 保持 `1-理解中` |
   | AI分析失败        | 记录错误日志到 t_kafka_message_log，更新状态为 `5-理解失败` | 更新为 `5-理解失败`   |
   | 数据保存失败      | 记录错误日志到 t_kafka_message_log，更新状态为 `5-理解失败` | 更新为 `5-理解失败`   |

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "message": "AI理解任务已启动",                 // string - 响应消息
  "data": {
    "understand_status": 1                    // int - 理解状态（当前为1-理解中，AI处理完成后会变为2-待确认）
  }
}
```

**状态校验失败响应**：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "当前状态不允许生成",               // string - 响应消息
  "data": {
    "error_type": "invalid_status",           // string - 错误类型
    "current_status": 2,                      // int - 当前理解状态
    "allowed_status": [0, 3]                  // array - 允许生成的状态（0-未理解, 3-已完成）
  }
}
```

**AI服务异常响应**：

```json
{
  "code": 503,                                 // int - 响应状态码
  "message": "服务器繁忙，请稍后再试",           // string - 响应消息
  "data": {
    "error_type": "ai_service_unavailable",   // string - 错误类型
    "understand_status": 0                    // int - 理解状态回退到未理解
  }
}
```

**说明**：

- 如果AI服务不可用或超时，状态回退到 `0-未理解`，前端提示用户"服务器繁忙，请稍后再试"

---

#### 4.3.7 保存库表信息补全数据

**接口路径**：`PUT /api/v1/data-semantic/{id}/semantic-info`

**请求参数**：

| 参数名    | 类型   | 必填 | 说明                                                                                                                 |
| --------- | ------ | ---- | -------------------------------------------------------------------------------------------------------------------- |
| id        | string | 是   | 数据视图UUID                                                                                                         |
| tableData | object | 否   | 库表级别数据，包含：id（必填，UUID）、table_business_name、table_description                                         |
| fieldData | array  | 否   | 字段级别数据列表，每项包含：id（必填，UUID）、form_view_field_id、field_business_name、field_role、field_description |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**并发控制**：同一用户对同一库表1秒内只允许点击一次，使用 Redis 限流，Key 格式为 `库表UUID:用户ID`。

**请求体示例**：

```json
{
  "tableData": {
    "id": "uuid-xxx",
    "table_business_name": "员工信息表",
    "table_description": "用于存储员工的基础信息"
  },
  "fieldData": [
    {
      "id": 1234567891,
      "form_view_field_id": "field-uuid-xxx",
      "field_business_name": "姓名",
      "field_role": 2,
      "field_description": "员工真实姓名"
    },
    {
      "id": 1234567892,
      "form_view_field_id": "field-uuid-yyy",
      "field_business_name": "身份证号码",
      "field_role": 1,
      "field_description": "员工身份证号"
    }
  ]
}
```

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：请先使用接口6生成数据
   - `1-理解中`：正在生成数据，请等待完成
   - `2-待确认`：允许保存（更新临时表）
   - `3-已完成`：允许保存（更新临时表，需重新提交）
   - `4-已发布`：已发布，无法修改
2. **获取当前版本号**

   ```sql
   SELECT COALESCE(MAX(version), 10) AS current_version
   FROM t_form_view_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```
3. **处理库表级别数据（tableData）**

   **直接更新临时表记录（通过UUID定位）**：

   ```sql
   UPDATE t_form_view_info_temp
   SET
     table_business_name = {table_business_name},
     table_description = {table_description},
     user_id = {user_id},
     updated_at = NOW(3)
   WHERE id = {tableData.id}
     AND deleted_at IS NULL;
   ```
4. **处理字段级别数据（fieldData）**

   **遍历字段数据，逐个更新临时表（通过UUID定位）**：

   ```sql
   UPDATE t_form_view_field_info_temp
   SET
     field_business_name = {field_business_name},
     field_role = {field_role},
     field_description = {field_description},
     user_id = {user_id},
     updated_at = NOW(3)
   WHERE id = {fieldData.id}
     AND deleted_at IS NULL;
   ```
5. **数据校验规则**：

   - `table_business_name`：最大长度 255 字符
   - `table_description`：最大长度 300 字符
   - `field_business_name`：最大长度 255 字符
   - `field_role`：枚举值 1-8
   - `field_description`：最大长度 300 字符
6. **说明**：

   - 所有操作均为更新操作，通过UUID定位记录
   - 不递增版本号
   - `user_id` 不为空，表示用户手动操作
   - 无论"待确认"还是"已完成"状态，都更新临时表
   - 最终通过接口3提交才会将临时表数据同步到正式表

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "message": "保存成功"                         // string - 响应消息
}
```

**状态校验失败响应**：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "当前状态不允许保存",               // string - 响应消息
  "data": {
    "error_type": "invalid_status",           // string - 错误类型
    "current_status": 1,                      // int - 当前理解状态
    "allowed_status": [2, 3]                  // array - 允许保存的状态（2-待确认, 3-已完成）
  }
}
```

---

#### 4.3.8 保存业务对象及属性

**接口路径**：`PUT /api/v1/data-semantic/{id}/business-objects`

**请求参数**：

| 参数名 | 类型   | 必填 | 说明                                  |
| ------ | ------ | ---- | ------------------------------------- |
| id     | string | 是   | 数据视图UUID                          |
| type   | string | 是   | 类型：object-业务对象，attribute-属性 |
| id     | string | 是   | 业务对象或属性的UUID                  |
| name   | string | 是   | 新的名称                              |

**请求体示例（修改业务对象名称）**：

```json
{
  "type": "object",
  "id": "uuid-xxx",
  "name": "基础信息"
}
```

**请求体示例（修改属性名称）**：

```json
{
  "type": "attribute",
  "id": 1234567891,
  "name": "姓名"
}
```

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：请先使用接口6生成数据
   - `1-理解中`：正在生成数据，请等待完成
   - `2-待确认`：允许保存
   - `3-已完成`：允许保存
   - `4-已发布`：已发布，无法修改
2. **根据 type 区分处理**

   **2.1 处理业务对象名称更新（type = 'object'）**

   **校验业务对象名称是否重复**：

   ```sql
   -- 检查同一库表中是否存在重名的业务对象
   SELECT COUNT(*) AS count
   FROM t_business_object_temp
   WHERE form_view_id = {form_view_id}
     AND id != {id}
     AND object_name = {name}
     AND deleted_at IS NULL;
   ```

   如果 count > 0，返回错误："库表中已存在业务对象「xxx」"

   **更新业务对象名称**：

   ```sql
   UPDATE t_business_object_temp
   SET
     object_name = {name},
     user_id = {user_id},
     updated_at = NOW(3)
   WHERE id = {id}
     AND deleted_at IS NULL;
   ```

   **2.2 处理属性名称更新（type = 'attribute'）**

   **校验属性名称是否重复**：

   ```sql
   -- 获取属性所属业务对象
   SELECT business_object_id
   FROM t_business_object_attributes_temp
   WHERE id = {id} AND deleted_at IS NULL;

   -- 检查同一业务对象中是否存在重名属性
   SELECT COUNT(*) AS count
   FROM t_business_object_attributes_temp
   WHERE business_object_id = {business_object_id}
     AND id != {id}
     AND attr_name = {name}
     AND deleted_at IS NULL;
   ```

   如果 count > 0，返回错误："业务对象「xxx」中已存在属性「xxx」"

   **更新属性名称**：

   ```sql
   UPDATE t_business_object_attributes_temp
   SET
     attr_name = {name},
     user_id = {user_id},
     updated_at = NOW(3)
   WHERE id = {id}
     AND deleted_at IS NULL;
   ```
3. **数据校验规则**：

   - `name`：最大长度 100 字符
   - 同一个库表下允许出现重名的业务对象
   - 同一个库表同一个业务对象中不允许出现重名的属性

**响应数据**：

```json
{
  "code": 200,
  "message": "修改成功",
  "data": {
    "id": 1
  }
}
```

**校验失败响应**：

业务对象名称重复：

```json
{
  "code": 400,
  "message": "业务对象名称重复",
  "data": {
    "error_type": "duplicate_object_name",
    "error_detail": "库表中已存在业务对象「基础信息」"
  }
}
```

属性名称重复：

```json
{
  "code": 400,
  "message": "属性名称重复",
  "data": {
    "error_type": "duplicate_attr_name",
    "error_detail": "业务对象「基础信息」中已存在属性「姓名」"
  }
}
```

**状态校验失败响应**：

```json
{
  "code": 400,
  "message": "当前状态不允许保存",
  "data": {
    "error_type": "invalid_status",
    "current_status": 1,
    "allowed_status": [2, 3]
  }
}
```

---

#### 4.3.9 调整属性归属业务对象

**接口路径**：`PUT /api/v1/data-semantic/{id}/business-objects/attributes/move`

**请求参数**：

| 参数名             | 类型   | 必填 | 说明                 |
| ------------------ | ------ | ---- | -------------------- |
| id                 | string | 是   | 数据视图UUID         |
| attribute_id       | string | 是   | 属性ID（临时表UUID） |
| target_object_uuid | string | 是   | 目标业务对象UUID     |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**并发控制**：同一用户对同一库表1秒内只允许点击一次，使用 Redis 限流，Key 格式为 `库表UUID:用户ID`。

**请求体示例**：

```json
{
  "attribute_id": "uuid-xxx",
  "target_object_uuid": "xxx"
}
```

**处理逻辑**：

1. **校验当前 understand_status**

   ```sql
   SELECT understand_status FROM form_view WHERE id = {form_view_id};
   ```

   - `0-未理解`：请先使用接口6生成数据
   - `1-理解中`：正在生成数据，请等待完成
   - `2-待确认`：允许调整
   - `3-已完成`：允许调整
   - `4-已发布`：已发布，无法修改
2. **获取当前版本号**

   ```sql
   SELECT COALESCE(MAX(version), 10) AS current_version
   FROM t_business_object_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```
3. **校验目标业务对象是否存在**

   ```sql
   SELECT uuid, object_name
   FROM t_business_object_temp
   WHERE uuid = {target_object_uuid}
     AND form_view_id = {form_view_id}
     AND version = {current_version}
     AND deleted_at IS NULL;
   ```

   如果不存在，返回错误："目标业务对象不存在"
4. **校验目标业务对象中是否已存在同名属性**

   ```sql
   -- 先获取当前属性名称
   SELECT attr_name, business_object_id AS old_object_id
   FROM t_business_object_attributes_temp
   WHERE id = {attribute_id}
     AND form_view_id = {form_view_id}
     AND version = {current_version}
     AND deleted_at IS NULL;

   -- 检查目标业务对象中是否已存在同名属性
   SELECT COUNT(*) AS count
   FROM t_business_object_attributes_temp
   WHERE business_object_id = {target_object_id}
     AND form_view_id = {form_view_id}
     AND attr_name = {attr_name}
     AND id != {attribute_id}
     AND version = {current_version}
     AND deleted_at IS NULL;
   ```

   如果 count > 0，返回错误："目标业务对象「xxx」中已存在属性「xxx」"
5. **更新属性所属业务对象**

   ```sql
   UPDATE t_business_object_attributes_temp
   SET
     business_object_id = {target_object_id},
     user_id = {user_id},
     updated_at = NOW(3)
   WHERE id = {attribute_id}
     AND form_view_id = {form_view_id}
     AND deleted_at IS NULL;
   ```
6. **检查原业务对象是否为空，如果为空可以选择性处理**

   ```sql
   SELECT COUNT(*) AS attr_count
   FROM t_business_object_attributes_temp
   WHERE business_object_id = {old_object_id}
     AND form_view_id = {form_view_id}
     AND version = {current_version}
     AND deleted_at IS NULL;
   ```

   **说明**：

   - 如果原业务对象的属性数量为 0，允许业务对象为空（不强制删除）
   - 前端可以选择性隐藏空业务对象，或保留显示
7. **说明**：

   - 不递增版本号
   - `user_id` 不为空，表示用户手动操作
   - 允许业务对象变为空（将所有属性移走后，原业务对象可以为空）
   - 原业务对象即使为空也不自动删除，保留记录

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "message": "调整成功",                        // string - 响应消息
  "data": {
    "attribute_id": "uuid-xxx",                // string - 属性ID
    "business_object_id": "xxx"        // string - 新所属业务对象UUID
  }
}
```

**校验失败响应**：

目标业务对象不存在：

```json
{
  "code": 404,                                 // int - 响应状态码
  "message": "目标业务对象不存在",               // string - 响应消息
  "data": {
    "error_type": "object_not_found",         // string - 错误类型
    "error_detail": "业务对象ID「2」不存在"     // string - 错误详情
  }
}
```

属性名称重复：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "属性名称重复",                     // string - 响应消息
  "data": {
    "error_type": "duplicate_attr_name",      // string - 错误类型（duplicate_attr_name-属性名称重复）
    "error_detail": "目标业务对象「联系方式」中已存在属性「手机号」" // string - 错误详情
  }
}
```

**状态校验失败响应**：

```json
{
  "code": 400,                                 // int - 响应状态码
  "message": "当前状态不允许调整",               // string - 响应消息
  "data": {
    "error_type": "invalid_status",           // string - 错误类型
    "current_status": 1,                      // int - 当前理解状态
    "allowed_status": [2, 3]                  // array - 允许调整的状态（2-待确认, 3-已完成）
  }
}
```

---

#### 4.3.10 查询库表理解状态

**接口路径**：`GET /api/v1/data-semantic/{id}/status`

**请求参数**：

| 参数名 | 类型   | 必填 | 说明         |
| ------ | ------ | ---- | ------------ |
| id     | string | 是   | 数据视图UUID |

**请求头**：

| 参数名        | 类型   | 必填 | 说明          |
| ------------- | ------ | ---- | ------------- |
| Authorization | string | 是   | 用户鉴权Token |

**响应数据**：

```json
{
  "code": 200,                                 // int - 响应状态码
  "data": {
    "understand_status": 2,                   // int - 理解状态（0-未理解,1-理解中,2-待确认,3-已完成,4-已发布）
    "current_version": 10                     // int - 当前版本号（存储格式：10=1.0，显示时除以10）
  }
}
```

**处理逻辑**：

1. **查询理解状态**

   ```sql
   SELECT understand_status
   FROM form_view
   WHERE id = {form_view_id} AND deleted_at IS NULL;
   ```
2. **查询当前版本号**

   ```sql
   SELECT COALESCE(MAX(version), 10) AS current_version
   FROM t_form_view_info_temp
   WHERE form_view_id = {form_view_id} AND deleted_at IS NULL;
   ```

**说明**：

- 此接口用于前端轮询查询库表理解状态，特别是在 `1-理解中` 状态下
- 前端通过 `current_version` 字段判断数据是否有更新（版本号变化即表示数据更新）

---

### 4.4 版本号管理规则

**版本号设计原则**：采用统一版本号管理，所有临时表共享同一个版本号。

| 接口                         | 版本号变化 | 说明                                                                                                                                                                  |
| ---------------------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 接口6 - 一键生成理解数据     | 递增       | 生成新版本时，递增所有临时表（`t_form_view_info_temp`、`t_form_view_field_info_temp`、`t_business_object_temp`、`t_business_object_attributes_temp`）的版本号 |
| 接口5 - 重新识别业务对象     | 递增       | 重新识别业务对象时，递增 `t_business_object_temp` 和 `t_business_object_attributes_temp` 的版本号                                                                 |
| 接口7 - 保存库表信息补全数据 | 不递增     | 在当前最新版本上进行更新                                                                                                                                              |
| 接口8 - 保存业务对象及属性   | 不递增     | 在当前最新版本上进行更新                                                                                                                                              |
| 接口9 - 调整属性归属业务对象 | 不递增     | 在当前最新版本上进行更新                                                                                                                                              |

**总结**：

- 接口6（一键生成）：递增所有临时表的版本号
- 接口5（重新识别）：只递增业务对象相关临时表的版本号
- 其他编辑操作：在当前最新版本上进行更新，不递增版本号

---

### 4.5 临时表数据处理策略

**临时表数据保留策略**：所有临时表数据在提交后**保留**，不删除。

**重新生成时的处理方式**：

| 场景                     | 涉及临时表         | 处理方式                         |
| ------------------------ | ------------------ | -------------------------------- |
| 接口6 - 一键生成理解数据 | 所有临时表         | 新增记录，版本号递增，旧记录保留 |
| 接口5 - 重新识别业务对象 | 业务对象相关临时表 | 新增记录，版本号递增，旧记录保留 |

**查询时数据来源**：

- 查询接口总是返回**最新版本**的数据
- 旧版本数据作为历史记录保留，不返回给前端

**说明**：

- 采用"新增记录"而非"更新记录"的方式，可以保留完整的修改历史
- 每次重新生成都会创建新版本的记录，便于追溯和对比
- 查询时通过版本号筛选，只返回最新版本的数据

---

### 4.5 接口调用时序图

```text
用户点击"开始理解"
    ↓
[接口6] 启动AI理解任务 (异步)
    ↓ understand_status: 0 → 1 (立即设置)
    ↓ (后台异步处理)
    ↓ understand_status: 1 → 2 (AI完成后自动设置)
用户查看/编辑字段语义
    ↓
[接口1] 查询库表信息临时表数据
    ↓
[接口7] 保存库表信息补全数据
用户查看/编辑业务对象
    ↓
[接口2] 查询业务对象和属性临时数据
    ↓
[接口8] 保存业务对象及属性
    ↓
[接口9] 调整属性归属业务对象（可选）
用户点击"重新识别"
    ↓
[接口5] 重新识别业务对象和属性临时数据
用户点击"提交确认"
    ↓
[接口3] 提交数据 (临时表 → 正式表)
    ↓ understand_status: 2 → 3
用户点击"删除"
    ↓
[接口4] 删除业务对象和属性临时数据
    ↓ understand_status: 2 → 0/3 或 3 → 0/3 (根据正式表是否有数据判断：有数据保持3，无数据回退到0)
```

---

### 4.7 理解状态流转

| 当前状态 | 可调用接口 | 调用后状态                                   |
| -------- | ---------- | -------------------------------------------- |
| 0-未理解 | 接口6      | 1-理解中（异步AI分析）                       |
| 1-理解中 | -          | 2-待确认（AI成功后自动流转）                 |
| 1-理解中 | -          | 5-理解失败（AI失败后自动流转）                |
| 2-待确认 | 接口3      | 3-已完成                                     |
| 2-待确认 | 接口5      | 2-待确认（数据刷新）                         |
| 2-待确认 | 接口4      | 0-未理解或3-已完成（取决于正式表是否有数据） |
| 3-已完成 | 接口4      | 0-未理解或3-已完成（取决于正式表是否有数据） |
| 3-已完成 | -          | 4-已发布（业务对象建模阶段）                 |
| 4-已发布 | -          | -                                            |
| 5-理解失败 | 接口6      | 1-理解中（重新尝试）                         |

**说明**：

- `0-未理解` → `1-理解中`：用户点击"开始理解"按钮后立即设置
- `1-理解中` → `2-待确认`：AI异步处理成功后自动设置，前端需要轮询或接收通知来获取状态变化
- `1-理解中` → `5-理解失败`：AI异步处理失败后自动设置，用户可重新尝试
- `5-理解失败` → `1-理解中`：用户点击"开始理解"按钮后重新尝试
- **接口4删除回退逻辑**：删除业务对象临时数据后，检查正式表是否存在业务对象数据
  - 有正式数据 → 保持 `3-已完成`
  - 无正式数据 → 回退到 `0-未理解`

---

### 4.8 正式表增量更新策略

**设计背景**：业务对象可能被其他系统或模块通过 ID 引用，全量替换会导致引用失效。

**核心机制**：通过临时表的 `formal_id` 字段实现增量更新。

#### 4.8.1 formal_id 字段说明

| 字段名     | 类型     | 说明                                     |
| ----------- | -------- | ---------------------------------------- |
| formal_id   | CHAR(36) | 关联正式表ID，用于增量更新匹配             |
|             |          | - 首次提交时为 NULL                       |
|             |          | - 提交后回写新生成的正式表 ID              |
|             |          | - 再次提交时用于精确匹配需更新的记录       |

#### 4.8.2 提交流程

```
┌─────────────────────────────────────────────────────────────────┐
│                        提交流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  临时表数据                         正式表操作                  │
│  ┌─────────────────┐               ┌─────────────────────────┐ │
│  │ formal_id IS NULL│──────────────▶│ INSERT 新增记录          │ │
│  │                 │               │ 获取新 ID 并回写         │ │
│  └─────────────────┘               └─────────────────────────┘ │
│                                                                 │
│  ┌─────────────────┐               ┌─────────────────────────┐ │
│  │ formal_id NOT NULL│─────────────▶│ UPDATE 更新记录          │ │
│  │                 │               │ 通过 formal_id 定位      │ │
│  └─────────────────┘               └─────────────────────────┘ │
│                                                                 │
│  ┌─────────────────┐               ┌─────────────────────────┐ │
│  │ 临时表中不存在    │◀──────────────│ DELETE 逻辑删除记录      │ │
│  │                 │               │ 删除不再需要的记录        │ │
│  └─────────────────┘               └─────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 4.8.3 示例场景

**场景：用户首次提交后再次编辑提交**

| 步骤 | 临时表状态 (formal_id) | 正式表操作 | 说明 |
|------|------------------------|-----------|------|
| 1 | 全部为 NULL | INSERT 3条记录 | 首次提交，生成新 ID: obj_1, obj_2, obj_3 |
| 2 | 回写: obj_1, obj_2, obj_3 | - | 将新 ID 回写到临时表 formal_id |
| 3 | 用户修改 obj_2 名称，删除 obj_3 | - | 临时表保留3条，formal_id 保持不变 |
| 4 | - | UPDATE obj_2 | 通过 formal_id= obj_2 精确更新 |
| 5 | - | DELETE obj_3 | 临时表无此记录，逻辑删除正式表对应记录 |
| 6 | - | INSERT obj_4 | 临时表有新记录（formal_id=NULL），新增 |

**结果**：
- obj_1: 保持不变（ID 稳定）
- obj_2: 更新了名称（ID 不变）
- obj_3: 逻辑删除（ID 不变，deleted_at 有值）
- obj_4: 新增记录

#### 4.8.4 优势总结

| 对比项 | 全量替换（旧方案） | 增量更新（新方案） |
|--------|-------------------|-------------------|
| ID 稳定性 | 每次都变 | 保持不变 |
| 外部引用 | 会失效 | 不受影响 |
| 审计追踪 | 只能看到最后一次 | 可追溯每次变更 |
| 数据库开销 | DELETE 全部 + INSERT 全部 | 只操作变化部分 |
